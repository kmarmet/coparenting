// Generated by CoffeeScript 2.7.0
var CalendarManager;

import DB from "../database/DB";

import {
  child,
  getDatabase,
  ref,
  remove,
  set,
  update
} from 'firebase/database';

import Manager from "./manager";

import LogManager from "./logManager";

import DateFormats from "../constants/datetimeFormats";

import moment from "moment";

import DateManager from "./dateManager";

import CalendarMapper from "../mappers/calMapper";

import DatasetManager from "./datasetManager";

import CalendarEvent from "../models/calendarEvent";

import ObjectManager from "./objectManager";

import ModelNames from "../models/modelNames";

export default CalendarManager = {
  addMultipleCalEvents: async function(currentUser, newEvents, isRangeClonedOrRecurring = false) {
    var currentEvents, dbRef, error, event, i, len, multipleDatesId, toAdd;
    dbRef = ref(getDatabase());
    currentEvents = (await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`));
    multipleDatesId = Manager.getUid();
    if (isRangeClonedOrRecurring = true) {
      for (i = 0, len = newEvents.length; i < len; i++) {
        event = newEvents[i];
        event.multipleDatesId = multipleDatesId;
      }
    }
    if (!Manager.isValid(currentEvents)) {
      toAdd = [...newEvents];
    } else {
      toAdd = [...currentEvents, ...newEvents];
    }
    try {
      return (await set(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/`), toAdd));
    } catch (error1) {
      error = error1;
      return LogManager.log(error.message, LogManager.logTypes.error, error.stack);
    }
  },
  buildArrayOfEvents: function(currentUser, eventObject, arrayType = "recurring", startDate, endDate) {
    var date, dateObject, datesToIterate, datesToPush, i, len;
    datesToPush = [];
    datesToIterate = [];
    // DATE RANGE / CLONED
    if (arrayType === "range" || arrayType === "cloned") {
      datesToIterate = DateManager.getDateRangeDates(startDate, endDate);
    }
    // REPEATING
    if (arrayType === "recurring") {
      datesToIterate = CalendarMapper.recurringEvents(eventObject.repeatInterval, moment(startDate).format(DateFormats.monthDayYear), endDate);
    }
    for (i = 0, len = datesToIterate.length; i < len; i++) {
      date = datesToIterate[i];
      dateObject = new CalendarEvent();
      // Required
      dateObject.title = eventObject.title;
      dateObject.id = Manager.getUid();
      dateObject.startDate = moment(date).format(DateFormats.dateForDb);
      dateObject.endDate = moment(endDate).format(DateFormats.dateForDb);
      if (arrayType === "range") {
        dateObject.staticStartDate = moment(datesToIterate[0]).format(DateFormats.dateForDb);
      }
      // Not Required
      dateObject.directionsLink = Manager.getDirectionsLink(eventObject.location);
      dateObject.location = eventObject.location;
      dateObject.children = eventObject.children;
      dateObject.ownerKey = currentUser != null ? currentUser.key : void 0;
      dateObject.createdBy = currentUser != null ? currentUser.name : void 0;
      dateObject.phone = eventObject.phone;
      dateObject.shareWith = DatasetManager.getUniqueArray(eventObject.shareWith, true);
      dateObject.notes = eventObject.notes;
      dateObject.websiteUrl = eventObject.websiteUrl;
      dateObject.isRecurring = eventObject.isRecurring;
      dateObject.isDateRange = eventObject.isDateRange;
      //      dateObject.isCloned = Manager.isValid(clonedDates)

      // Times
      if (Manager.isValid(eventObject.startTime)) {
        dateObject.startTime = moment(eventObject.startTime).format(DateFormats.timeForDb);
      }
      if (Manager.isValid(eventObject.endTime)) {
        dateObject.endTime = moment(eventObject.endTime).format(DateFormats.timeForDb);
      }
      dateObject.reminderTimes = eventObject.reminderTimes;
      dateObject.recurrenceInterval = eventObject.repeatInterval;
      dateObject = ObjectManager.cleanObject(dateObject, ModelNames.calendarEvent);
      datesToPush.push(dateObject);
    }
    console.log(datesToPush);
    return datesToPush;
  },
  setHolidays: async function(holidays) {
    var currentEvents, dbRef, error, eventsToAdd;
    dbRef = ref(getDatabase());
    currentEvents = (await DB.getTable(DB.tables.holidayEvents));
    eventsToAdd = [...currentEvents, ...holidays].filter(function(x) {
      return x != null;
    }).flat();
    try {
      return (await set(child(dbRef, `${DB.tables.holidayEvents}`), eventsToAdd));
    } catch (error1) {
      error = error1;
      return LogManager.log(error.message, LogManager.logTypes.error, error.stack);
    }
  },
  addCalendarEvent: async function(currentUser, newEvent) {
    var currentEvents, dbRef, error, toAdd;
    dbRef = ref(getDatabase());
    currentEvents = (await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`));
    currentEvents = currentEvents.filter(function(n) {
      return n;
    });
    toAdd = [];
    try {
      if (Manager.isValid(currentEvents)) {
        toAdd = [...currentEvents, newEvent];
      } else {
        toAdd = [newEvent];
      }
      return set(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/`), toAdd);
    } catch (error1) {
      error = error1;
      return LogManager.log(error.message, LogManager.logTypes.error, error.stack);
    }
  },
  updateEvent: async function(userKey, event, prop, value) {
    var dbRef, error, key, tableRecords, toUpdate;
    dbRef = getDatabase();
    key = (await DB.getSnapshotKey(`${DB.tables.calendarEvents}/${userKey}`, event, 'id'));
    tableRecords = (await DB.getTable(`${DB.tables.calendarEvents}/${userKey}`));
    toUpdate = tableRecords.find((x) => {
      return x.id === (event != null ? event.id : void 0);
    });
    toUpdate[prop] = value;
    try {
      return update(ref(dbRef, `${DB.tables.calendarEvents}/${userKey}/${key}`), toUpdate);
    } catch (error1) {
      error = error1;
      return LogManager.log(error.message, LogManager.logTypes.error, error.stack);
    }
  },
  updateMultipleEvents: async function(events, currentUser) {
    var dbRef, event, existingEvents, i, key, len, path, results, updatedEvent;
    dbRef = getDatabase();
    path = `${DB.tables.calendarEvents}/${currentUser.key}`;
    existingEvents = (await DB.getTable(path));
    if (Manager.isValid(events)) {
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        updatedEvent = events[i];
        results.push((await (async function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = existingEvents.length; j < len1; j++) {
            event = existingEvents[j];
            if (event.id === updatedEvent.id) {
              key = (await DB.getSnapshotKey(path, event, 'id'));
              await DB.deleteByPath(`${path}/${key}`);
              await DB.add(`${path}/${key}`, event);
              results1.push((await update(ref(dbRef, `${path}/${key}`), updatedEvent)));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })()));
      }
      return results;
    }
  },
  deleteMultipleEvents: async function(events, currentUser) {
    var dbRef, i, idsToDelete, len, record, results, tableRecords;
    dbRef = ref(getDatabase());
    tableRecords = (await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`));
    idsToDelete = events.map(function(x) {
      return x.id;
    });
    if (Manager.isValid(tableRecords)) {
      results = [];
      for (i = 0, len = tableRecords.length; i < len; i++) {
        record = tableRecords[i];
        if (Manager.contains(idsToDelete, record.id)) {
          results.push((await CalendarManager.deleteEvent(currentUser, record.id)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  },
  deleteAllHolidayEvents: async function() {
    var dbRef, i, idToDelete, len, record, results, tableRecords;
    dbRef = ref(getDatabase());
    tableRecords = (await DB.getTable(`${DB.tables.holidayEvents}`));
    results = [];
    for (i = 0, len = tableRecords.length; i < len; i++) {
      record = tableRecords[i];
      idToDelete = (await DB.getSnapshotKey(`${DB.tables.holidayEvents}`, record, 'id'));
      results.push((await remove(child(dbRef, `${DB.tables.holidayEvents}/${idToDelete}`))));
    }
    return results;
  },
  deleteEvent: async function(currentUser, id) {
    var dbRef, error, i, idToDelete, len, record, results, tableRecords;
    dbRef = ref(getDatabase());
    idToDelete = null;
    tableRecords = (await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}/`));
    results = [];
    for (i = 0, len = tableRecords.length; i < len; i++) {
      record = tableRecords[i];
      if ((record != null ? record.id : void 0) === id) {
        idToDelete = (await DB.getSnapshotKey(`${DB.tables.calendarEvents}/${currentUser.key}/`, record, 'id'));
        try {
          results.push(remove(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/${idToDelete}`)));
        } catch (error1) {
          error = error1;
          results.push(LogManager.log(error.message, LogManager.logTypes.error, error.stack));
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  }
};

//# sourceMappingURL=calendarManager.js.map
