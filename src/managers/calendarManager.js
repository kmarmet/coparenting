// Generated by CoffeeScript 2.7.0
var CalendarManager

import * as Sentry from '@sentry/react'

import {child, getDatabase, ref, remove, set, update} from 'firebase/database'

import moment from 'moment'

import DateFormats from '../constants/datetimeFormats'
import DB from '../database/DB'

import CalendarMapper from '../mappers/calMapper'

import CalendarEvent from '../models/calendarEvent'

import ModelNames from '../models/modelNames'

import DatasetManager from './datasetManager'

import DateManager from './dateManager'

import LogManager from './logManager'

import Manager from './manager'

import ObjectManager from './objectManager'

export default CalendarManager = {
  addMultipleCalEvents: async function (currentUser, newEvents, isRangeClonedOrRecurring = false) {
    var currentEvents, dbRef, error, event, i, len, multipleDatesId, toAdd
    dbRef = ref(getDatabase())
    currentEvents = await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`)
    multipleDatesId = Manager.GetUid()
    if ((isRangeClonedOrRecurring = true)) {
      for (i = 0, len = newEvents.length; i < len; i++) {
        event = newEvents[i]
        event.multipleDatesId = multipleDatesId
      }
    }
    if (!Manager.IsValid(currentEvents)) {
      toAdd = [...newEvents]
    } else {
      toAdd = [...currentEvents, ...newEvents]
    }
    try {
      return await set(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/`), toAdd)
    } catch (error1) {
      error = error1
      return LogManager.Log(error.message, LogManager.LogTypes.error, error.stack)
    }
  },
  buildArrayOfEvents: function (currentUser, eventObject, arrayType = 'recurring', startDate, endDate) {
    var date, dateObject, datesToIterate, datesToPush, i, len
    datesToPush = []
    datesToIterate = []
    // DATE RANGE / CLONED
    if (arrayType === 'range' || arrayType === 'cloned') {
      datesToIterate = DateManager.getDateRangeDates(startDate, endDate)
    }
    // REPEATING
    if (arrayType === 'recurring') {
      datesToIterate = CalendarMapper.recurringEvents(eventObject.repeatInterval, moment(startDate).format(DateFormats.monthDayYear), endDate)
    }
    for (i = 0, len = datesToIterate.length; i < len; i++) {
      date = datesToIterate[i]
      dateObject = new CalendarEvent()
      // Required
      dateObject.title = eventObject.title
      dateObject.id = Manager.GetUid()
      dateObject.startDate = moment(date).format(DateFormats.dateForDb)
      dateObject.endDate = moment(endDate).format(DateFormats.dateForDb)
      if (arrayType === 'range') {
        dateObject.staticStartDate = moment(datesToIterate[0]).format(DateFormats.dateForDb)
      }
      // Not Required
      dateObject.directionsLink = Manager.GetDirectionsLink(eventObject.location)
      dateObject.location = eventObject.location
      dateObject.children = eventObject.children
      dateObject.ownerKey = currentUser != null ? currentUser.key : void 0
      dateObject.createdBy = currentUser != null ? currentUser.name : void 0
      dateObject.phone = eventObject.phone
      dateObject.shareWith = DatasetManager.getUniqueArray(eventObject.shareWith, true)
      dateObject.notes = eventObject.notes
      dateObject.websiteUrl = eventObject.websiteUrl
      dateObject.isRecurring = eventObject.isRecurring
      dateObject.isDateRange = eventObject.isDateRange
      //      dateObject.isCloned = Manager.isValid(clonedDates)

      // Times
      if (Manager.IsValid(eventObject.startTime)) {
        dateObject.startTime = moment(eventObject.startTime).format(DateFormats.timeForDb)
      }
      if (Manager.IsValid(eventObject.endTime)) {
        dateObject.endTime = moment(eventObject.endTime).format(DateFormats.timeForDb)
      }
      dateObject.reminderTimes = eventObject.reminderTimes
      dateObject.recurrenceInterval = eventObject.repeatInterval
      dateObject = ObjectManager.GetModelValidatedObject(dateObject, ModelNames.calendarEvent)
      datesToPush.push(dateObject)
    }
    console.log(datesToPush)
    return datesToPush
  },
  setHolidays: async function (holidays) {
    var currentEvents, dbRef, error, eventsToAdd
    dbRef = ref(getDatabase())
    currentEvents = await DB.getTable(DB.tables.holidayEvents)
    eventsToAdd = [...currentEvents, ...holidays]
      .filter(function (x) {
        return x != null
      })
      .flat()
    try {
      return await set(child(dbRef, `${DB.tables.holidayEvents}`), eventsToAdd)
    } catch (error1) {
      error = error1
      return LogManager.Log(error.message, LogManager.LogTypes.error, error.stack)
    }
  },
  addCalendarEvent: async function (currentUser, newEvent) {
    var currentEvents, dbRef, error, toAdd
    dbRef = ref(getDatabase())
    currentEvents = await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`)
    currentEvents = currentEvents.filter(function (n) {
      return n
    })
    toAdd = []
    try {
      if (Manager.IsValid(currentEvents)) {
        toAdd = [...currentEvents, newEvent]
      } else {
        toAdd = [newEvent]
      }
      return set(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/`), toAdd)
    } catch (error1) {
      error = error1
      return LogManager.Log(error.message, LogManager.LogTypes.error, error.stack)
    }
  },
  UpdateEvent: async function (currentUserKey, updateIndex, updatedEvent) {
    var dbRef, error
    dbRef = getDatabase()
    try {
      if (updateIndex) {
        return await update(ref(dbRef, `${DB.tables.calendarEvents}/${currentUserKey}/${updateIndex}`), updatedEvent)
      }
    } catch (error1) {
      error = error1
      return Sentry.captureException(`Error: ${error} | Code File: CalendarManager | Function: UpdateExpense`)
    }
  },
  deleteMultipleEvents: async function (events, currentUser) {
    var dbRef, i, idsToDelete, len, record, results, tableRecords
    dbRef = ref(getDatabase())
    tableRecords = await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}`)
    idsToDelete = events.map(function (x) {
      return x.id
    })
    if (Manager.IsValid(tableRecords)) {
      results = []
      for (i = 0, len = tableRecords.length; i < len; i++) {
        record = tableRecords[i]
        if (Manager.Contains(idsToDelete, record.id)) {
          results.push(await CalendarManager.deleteEvent(currentUser, record.id))
        } else {
          results.push(void 0)
        }
      }
      return results
    }
  },
  deleteAllHolidayEvents: async function () {
    var dbRef, i, idToDelete, len, record, results, tableRecords
    dbRef = ref(getDatabase())
    tableRecords = await DB.getTable(`${DB.tables.holidayEvents}`)
    results = []
    for (i = 0, len = tableRecords.length; i < len; i++) {
      record = tableRecords[i]
      idToDelete = await DB.getSnapshotKey(`${DB.tables.holidayEvents}`, record, 'id')
      results.push(await remove(child(dbRef, `${DB.tables.holidayEvents}/${idToDelete}`)))
    }
    return results
  },
  deleteEvent: async function (currentUser, id) {
    var dbRef, error, i, idToDelete, len, record, results, tableRecords
    dbRef = ref(getDatabase())
    idToDelete = null
    tableRecords = await DB.getTable(`${DB.tables.calendarEvents}/${currentUser.key}/`)
    results = []
    for (i = 0, len = tableRecords.length; i < len; i++) {
      record = tableRecords[i]
      if ((record != null ? record.id : void 0) === id) {
        idToDelete = await DB.getSnapshotKey(`${DB.tables.calendarEvents}/${currentUser.key}/`, record, 'id')
        try {
          results.push(remove(child(dbRef, `${DB.tables.calendarEvents}/${currentUser.key}/${idToDelete}`)))
        } catch (error1) {
          error = error1
          results.push(LogManager.Log(error.message, LogManager.LogTypes.error, error.stack))
        }
      } else {
        results.push(void 0)
      }
    }
    return results
  },
}

//# sourceMappingURL=calendarManager.js.map