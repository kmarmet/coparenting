// Generated by CoffeeScript 2.7.0
  // Path: src/managers/chatManager.coffee
var ChatManager,
  indexOf = [].indexOf;

import {
  child,
  getDatabase,
  ref,
  set
} from 'firebase/database';

import DB from '../database/DB';

import Manager from '../managers/manager';

import ChatBookmark from '../models/chat/chatBookmark';

import DatasetManager from './datasetManager.coffee';

import LogManager from './logManager';

import SecurityManager from './securityManager';

import Chat from "../models/chat/chat";

import DB_UserScoped from "../database/db_userScoped";

import Apis from "../api/apis";

ChatManager = {
  CreateAndInsertChat: async function(sender, recipient) {
    var dbRef, error, existingChats, newChat, updatedChats;
    dbRef = ref(getDatabase());
    newChat = new Chat();
    newChat.id = Manager.GetUid();
    newChat.members = [{...recipient}, {...sender}];
    newChat.ownerKey = sender != null ? sender.key : void 0;
    existingChats = (await DB.getTable(`${DB.tables.chats}/${sender != null ? sender.key : void 0}`));
    updatedChats = DatasetManager.AddToArray(existingChats, newChat);
    try {
      await set(child(dbRef, `${DB.tables.chats}/${recipient != null ? recipient.key : void 0}`), updatedChats);
      await set(child(dbRef, `${DB.tables.chats}/${sender != null ? sender.key : void 0}`), updatedChats);
      return newChat.id;
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  InsertChatMessage: async function(chatId, message) {
    var currentMessages, dbRef, error, toAdd;
    try {
      dbRef = ref(getDatabase());
      currentMessages = (await DB.getTable(`${DB.tables.chatMessages}/${chatId}`));
      console.log(`${DB.tables.chatMessages}/${chatId}`, message);
      toAdd = DatasetManager.AddToArray(currentMessages, message);
      return (await set(child(dbRef, `${DB.tables.chatMessages}/${chatId}`), toAdd));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetInactiveChatKeys: async function(currentUser, chats = []) {
    var activeChatKeys, i, inactive, key, len, members, ref1, validAccountKeys, validAccounts;
    inactive = [];
    validAccounts = (await DB_UserScoped.getCoparentAccounts(currentUser));
    validAccounts = validAccounts != null ? validAccounts.filter((x) => {
      return x.accountType === 'parent';
    }) : void 0;
    validAccountKeys = validAccounts != null ? validAccounts.map((x) => {
      return x != null ? x.key : void 0;
    }) : void 0;
    members = chats != null ? chats.map((x) => {
      return x != null ? x.members : void 0;
    }) : void 0;
    activeChatKeys = members != null ? (ref1 = members.flat()) != null ? ref1.map((x) => {
      return x != null ? x.key : void 0;
    }) : void 0 : void 0;
    activeChatKeys = activeChatKeys != null ? activeChatKeys.filter((x) => {
      return x !== (currentUser != null ? currentUser.key : void 0);
    }) : void 0;
    if (Manager.IsValid(validAccounts)) {
      for (i = 0, len = validAccountKeys.length; i < len; i++) {
        key = validAccountKeys[i];
        if (!(activeChatKeys != null ? activeChatKeys.includes(key) : void 0)) {
          inactive.push(key);
        }
      }
    }
    return inactive;
  },
  GetToneAndSentiment: async function(message) {
    var color, icon, ref1, ref2, ref3, ref4, ref5, ref6, returnSentiment, returnTone, sentiment, tone, warningSentiments;
    tone = (await Apis.Sapler.GetToneOrSentiment('tone', message));
    sentiment = (await Apis.Sapler.GetToneOrSentiment('sentiment', message));
    if (!Manager.IsValid(tone) || !Manager.IsValid(sentiment)) {
      return false;
    }
    warningSentiments = ['sad'];
    returnTone = tone != null ? (ref1 = tone.overall) != null ? (ref2 = ref1[0]) != null ? ref2[1] : void 0 : void 0 : void 0;
    returnSentiment = sentiment != null ? (ref3 = sentiment.overall) != null ? (ref4 = ref3[0]) != null ? ref4[1] : void 0 : void 0 : void 0;
    icon = tone != null ? (ref5 = tone.overall) != null ? (ref6 = ref5[0]) != null ? ref6[2] : void 0 : void 0 : void 0;
    color = returnSentiment === 'NEGATIVE' ? 'red' : 'green';
    if (indexOf.call(warningSentiments, returnTone) >= 0) {
      color = 'yellow';
    }
    return {
      tone: returnTone,
      sentiment: returnSentiment,
      color: color,
      icon: icon
    };
  },
  GetScopedChat: async function(currentUser, messageToUserKey) {
    var chat, chatToReturn, error, i, len, memberKeys, securedChats;
    try {
      securedChats = (await SecurityManager.getChats(currentUser));
      console.log("Secured: ", securedChats);
      chatToReturn = null;
      for (i = 0, len = securedChats.length; i < len; i++) {
        chat = securedChats[i];
        memberKeys = chat.members.map(function(x) {
          return x.key;
        });
        if (memberKeys.includes(currentUser.key) && memberKeys.includes(messageToUserKey)) {
          chatToReturn = chat;
        }
      }
      return chatToReturn;
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetMessages: async function(chatId) {
    return (await DB.getTable(`${DB.tables.chatMessages}/${chatId}`));
  },
  PauseChat: async function(currentUser, coParentKey, chat) {
    var error, isPausedFor;
    try {
      isPausedFor = chat.isPausedFor;
      if (!Manager.IsValid(isPausedFor)) {
        isPausedFor = [currentUser != null ? currentUser.key : void 0];
      } else {
        isPausedFor = [...isPausedFor, currentUser != null ? currentUser.key : void 0];
      }
      isPausedFor = DatasetManager.getUniqueArray(isPausedFor, true);
      chat.isPausedFor = isPausedFor;
      // Set chat inactive
      await DB.updateEntireRecord(`${DB.tables.chats}/${currentUser != null ? currentUser.key : void 0}`, chat, chat.id);
      return (await DB.updateEntireRecord(`${DB.tables.chats}/${coParentKey}`, chat, chat.id));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  ResumeChat: async function(currentUser, coParentKey, chat) {
    var error, isPausedFor, ref1;
    try {
      isPausedFor = chat != null ? (ref1 = chat.isPausedFor) != null ? ref1.filter(function(x) {
        return x !== (currentUser != null ? currentUser.key : void 0);
      }) : void 0 : void 0;
      isPausedFor = DatasetManager.getUniqueArray(isPausedFor, true);
      chat.isPausedFor = isPausedFor;
      // Set chat inactive
      await DB.updateEntireRecord(`${DB.tables.chats}/${currentUser != null ? currentUser.key : void 0}`, chat, chat.id);
      return (await DB.updateEntireRecord(`${DB.tables.chats}/${coParentKey}`, chat, chat.id));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetBookmarks: async function(chatId) {
    var existingBookmarks;
    existingBookmarks = (await DB.getTable(`${DB.tables.chatBookmarks}/${chatId}`));
    existingBookmarks = DatasetManager.GetValidArray(existingBookmarks);
    return existingBookmarks;
  },
  ToggleMessageBookmark: function(currentUser, messageToUser, messageId, chatId, existingBookmarks) {
    var dbRef, error, existsAlready, newBookmark, updated;
    try {
      dbRef = ref(getDatabase());
      updated = [];
      newBookmark = new ChatBookmark();
      newBookmark.ownerKey = currentUser != null ? currentUser.key : void 0;
      newBookmark.messageId = messageId;
      existsAlready = existingBookmarks.find(function(x) {
        return (x != null ? x.messageId : void 0) === messageId;
      });
      if (Manager.IsValid(existsAlready)) {
        updated = existingBookmarks.filter(function(x) {
          return (x != null ? x.messageId : void 0) !== messageId;
        });
      } else {
        updated = DatasetManager.AddToArray(existingBookmarks, newBookmark);
      }
      return set(child(dbRef, `${DB.tables.chatBookmarks}/${chatId}`), updated);
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  }
};

export default ChatManager;

//# sourceMappingURL=chatManager.js.map
