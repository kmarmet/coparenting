// Generated by CoffeeScript 2.7.0
  // Path: src/managers/chatManager.coffee
var ChatManager,
  indexOf = [].indexOf;

import {
  child,
  getDatabase,
  ref,
  set
} from 'firebase/database';

import DB from '../database/DB';

import Manager from '../managers/manager';

import ChatBookmark from '../models/chat/chatBookmark';

import DatasetManager from './datasetManager.coffee';

import LogManager from './logManager';

import SecurityManager from './securityManager';

import Chat from "../models/chat/chat";

import DB_UserScoped from "../database/db_userScoped";

ChatManager = {
  CreateAndInsertChat: async function(sender, recipient) {
    var dbRef, error, existingChats, newChat, updatedChats;
    dbRef = ref(getDatabase());
    newChat = new Chat();
    newChat.members = [{...recipient}, {...sender}];
    newChat.ownerKey = sender != null ? sender.key : void 0;
    existingChats = (await DB.getTable(`${DB.tables.chats}/${sender != null ? sender.key : void 0}`));
    updatedChats = DatasetManager.AddToArray(existingChats, newChat);
    try {
      await set(child(dbRef, `${DB.tables.chats}/${recipient != null ? recipient.key : void 0}`), updatedChats);
      return (await set(child(dbRef, `${DB.tables.chats}/${sender != null ? sender.key : void 0}`), updatedChats));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  InsertChatMessage: async function(chatId, message) {
    var currentMessages, dbRef, error, toAdd;
    try {
      dbRef = ref(getDatabase());
      currentMessages = (await DB.getTable(`${DB.tables.chatMessages}/${chatId}`));
      console.log(`${DB.tables.chatMessages}/${chatId}`, message);
      toAdd = DatasetManager.AddToArray(currentMessages, message);
      return (await set(child(dbRef, `${DB.tables.chatMessages}/${chatId}`), toAdd));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetInactiveChatKeys: async function(currentUser, chats) {
    var coParentKeys, inactive, memberKeys, members, ref1, validAccountKeys, validAccounts;
    validAccounts = (await DB_UserScoped.getCoparentAccounts(currentUser));
    members = DatasetManager.getUniqueArray(chats.map((x) => {
      return x.members;
    }), true);
    memberKeys = DatasetManager.getUniqueArray(members.map((x) => {
      return x != null ? x.userKey : void 0;
    }), true);
    coParentKeys = DatasetManager.getUniqueArray(currentUser != null ? (ref1 = currentUser.coparents) != null ? ref1.map((x) => {
      return x != null ? x.userKey : void 0;
    }) : void 0 : void 0, true);
    validAccountKeys = validAccounts.map((x) => {
      return x != null ? x.userKey : void 0;
    });
    inactive = memberKeys.filter((x) => {
      return !coParentKeys.includes(x) && !validAccountKeys.includes(x);
    });
    return inactive;
  },
  GetToneAndSentiment: async function(message) {
    var color, icon, ref1, ref2, ref3, ref4, ref5, ref6, returnSentiment, returnTone, sentiment, tone, warningSentiments;
    tone = (await ChatManager.GetTone(message));
    sentiment = (await ChatManager.GetSentiment(message));
    if (!Manager.IsValid(tone) || !Manager.IsValid(sentiment)) {
      return false;
    }
    warningSentiments = ['sad'];
    returnTone = tone != null ? (ref1 = tone.overall) != null ? (ref2 = ref1[0]) != null ? ref2[1] : void 0 : void 0 : void 0;
    returnSentiment = sentiment != null ? (ref3 = sentiment.overall) != null ? (ref4 = ref3[0]) != null ? ref4[1] : void 0 : void 0 : void 0;
    icon = tone != null ? (ref5 = tone.overall) != null ? (ref6 = ref5[0]) != null ? ref6[2] : void 0 : void 0 : void 0;
    color = returnSentiment === 'NEGATIVE' ? 'red' : 'green';
    if (indexOf.call(warningSentiments, returnTone) >= 0) {
      color = 'yellow';
    }
    return {
      tone: returnTone,
      sentiment: returnSentiment,
      color: color,
      icon: icon
    };
  },
  GetSentiment: function(message) {
    return new Promise(function(resolve, reject) {
      return fetch('https://api.sapling.ai/api/v1/sentiment', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          key: '7E3IFZEMEKYEHVIMJHENF9ETHHTKARA4',
          text: message
        })
      }).then(function(response) {
        return response;
      }).then(function(result) {
        return resolve(result.json());
      }).catch(function(error) {
        console.log(error.message);
        return reject(error);
      });
    });
  },
  GetTone: function(message) {
    return new Promise(function(resolve, reject) {
      return fetch('https://api.sapling.ai/api/v1/tone', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          key: '7E3IFZEMEKYEHVIMJHENF9ETHHTKARA4',
          text: message
        })
      }).then(function(response) {
        return response;
      }).then(function(result) {
        return resolve(result.json());
      }).catch(function(error) {
        return reject(error);
      });
    });
  },
  GetScopedChat: async function(currentUser, messageToUserKey) {
    var chat, chatToReturn, error, i, len, memberKeys, securedChats;
    try {
      securedChats = (await SecurityManager.getChats(currentUser));
      chatToReturn = null;
      console.log(securedChats);
      for (i = 0, len = securedChats.length; i < len; i++) {
        chat = securedChats[i];
        memberKeys = chat.members.map(function(x) {
          return x.key;
        });
        if (memberKeys.includes(currentUser.key) && memberKeys.includes(messageToUserKey)) {
          chatToReturn = chat;
        }
      }
      return chatToReturn;
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetMessages: async function(chatId) {
    return (await DB.getTable(`${DB.tables.chatMessages}/${chatId}`));
  },
  PauseChat: async function(currentUser, coparentKey) {
    var error, isPausedFor, securedChat;
    securedChat = (await ChatManager.GetScopedChat(currentUser, coparentKey));
    try {
      isPausedFor = securedChat.isPausedFor;
      if (!Manager.IsValid(isPausedFor)) {
        isPausedFor = [currentUser != null ? currentUser.key : void 0];
      } else {
        isPausedFor = [...isPausedFor, currentUser != null ? currentUser.key : void 0];
      }
      isPausedFor = DatasetManager.getUniqueArray(isPausedFor, true);
      securedChat.isPausedFor = isPausedFor;
      // Set chat inactive
      await DB.updateEntireRecord(`${DB.tables.chats}/${currentUser != null ? currentUser.key : void 0}`, securedChat, securedChat.id);
      return (await DB.updateEntireRecord(`${DB.tables.chats}/${coparentKey}`, securedChat, securedChat.id));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  UnpauseChat: async function(currentUser, coparentKey) {
    var error, isPausedFor, ref1, securedChat;
    securedChat = (await ChatManager.GetScopedChat(currentUser, coparentKey));
    try {
      isPausedFor = securedChat != null ? (ref1 = securedChat.isPausedFor) != null ? ref1.filter(function(x) {
        return x !== (currentUser != null ? currentUser.key : void 0);
      }) : void 0 : void 0;
      isPausedFor = DatasetManager.getUniqueArray(isPausedFor, true);
      securedChat.isPausedFor = isPausedFor;
      // Set chat inactive
      await DB.updateEntireRecord(`${DB.tables.chats}/${currentUser != null ? currentUser.key : void 0}`, securedChat, securedChat.id);
      return (await DB.updateEntireRecord(`${DB.tables.chats}/${coparentKey}`, securedChat, securedChat.id));
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  },
  GetBookmarks: async function(chatId) {
    var existingBookmarks;
    existingBookmarks = (await DB.getTable(`${DB.tables.chatBookmarks}/${chatId}`));
    existingBookmarks = DatasetManager.GetValidArray(existingBookmarks);
    return existingBookmarks;
  },
  ToggleMessageBookmark: function(currentUser, messageToUser, messageId, chatId, existingBookmarks) {
    var dbRef, error, existsAlready, newBookmark, updated;
    try {
      dbRef = ref(getDatabase());
      updated = [];
      newBookmark = new ChatBookmark();
      newBookmark.ownerKey = currentUser != null ? currentUser.key : void 0;
      newBookmark.messageId = messageId;
      existsAlready = existingBookmarks.find(function(x) {
        return (x != null ? x.messageId : void 0) === messageId;
      });
      if (Manager.IsValid(existsAlready)) {
        updated = existingBookmarks.filter(function(x) {
          return (x != null ? x.messageId : void 0) !== messageId;
        });
      } else {
        updated = DatasetManager.AddToArray(existingBookmarks, newBookmark);
      }
      return set(child(dbRef, `${DB.tables.chatBookmarks}/${chatId}`), updated);
    } catch (error1) {
      error = error1;
      return LogManager.Log(error.message, LogManager.LogTypes.error);
    }
  }
};

export default ChatManager;

//# sourceMappingURL=chatManager.js.map
