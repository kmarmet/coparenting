// Generated by CoffeeScript 2.7.0
var DatasetManager;

import DB from "../database/DB";

import _ from "lodash";

import moment from "moment";

import Manager from "./manager";

import ObjectManager from "./objectManager";

DatasetManager = {
  GetDatabaseKeyFromArray: function(arr, getSingleObjectPropName, getSingleObjectProp) {
    var formatted;
    if (getSingleObjectProp) {
      formatted = Object.entries(arr).map(function(x) {
        return x[1];
      });
      console.log(ObjectManager.RecursivelyFindProperty(formatted, getSingleObjectPropName), getSingleObjectProp);
      return formatted.find(function(x) {
        return ObjectManager.RecursivelyFindProperty(formatted, getSingleObjectPropName) === getSingleObjectProp;
      });
    } else {
      return Object.entries(arr).flat();
    }
  },
  CombineArrays: function(arrOne = [], arrTwo = [], isUnique = true, isFlattened = true) {
    var returnArray;
    returnArray = [];
    arrOne = DatasetManager.GetValidArray(arrOne);
    arrTwo = DatasetManager.GetValidArray(arrTwo);
    if (Manager.IsValid(arrOne)) {
      returnArray = [...arrOne];
    }
    if (Manager.IsValid(arrTwo)) {
      returnArray = [...returnArray, ...arrTwo];
    }
    if (isUnique) {
      returnArray = DatasetManager.getUniqueArray(returnArray);
    }
    if (isFlattened) {
      returnArray = returnArray.flat();
    }
    return returnArray;
  },
  AddToArray: (arr, newItem, removeIfExistsAlready = false) => {
    var returnArray;
    returnArray = [];
    if (!Manager.IsValid(arr)) {
      returnArray = [newItem];
    }
    if (Manager.IsValid(arr) && Array.isArray(arr) && arr.length > 0) {
      returnArray = [...arr, newItem];
    }
    if (Manager.IsValid(arr) && Array.isArray(arr) && arr.length === 0) {
      returnArray = [newItem];
    }
    if (Manager.IsValid(arr) && !Array.isArray(arr)) {
      returnArray = [newItem];
    }
    if (removeIfExistsAlready && arr.includes(newItem)) {
      returnArray = returnArray.filter(function(x) {
        return x !== newItem;
      });
    }
    if (Manager.IsValid(returnArray)) {
      returnArray = DatasetManager.GetValidArray(returnArray);
    }
    return returnArray;
  },
  ToggleInArray: function(arr, key) {
    if (!Manager.IsValid(arr)) {
      return [key];
    } else {
      if (arr.includes(key)) {
        return arr.filter(function(x) {
          return x !== key;
        });
      } else {
        return [...arr, key];
      }
    }
  },
  GetValidArray: function(source, isUnique = true, isFlattened = true, getObjectValuesOnly = false) {
    var asArray, returnArray;
    returnArray = [];
    if (!Manager.IsValid(source)) {
      return [];
    }
    asArray = function(key) {
      ({
        id: key
      });
      return source[key];
    };
    asArray = Object.keys(source).map(asArray);
    returnArray = asArray;
    if (!Manager.IsValid(asArray)) {
      // NOT Array
      if (!Array.isArray(source)) {
        source = [source];
      }
      // Array
      if (Array.isArray(source)) {
        returnArray = returnArray.filter(function(x) {
          return x;
        });
      }
    }
    if (isUnique) {
      returnArray = DatasetManager.getUniqueArray(returnArray);
    }
    if (isFlattened) {
      returnArray = returnArray.flat();
    }
    return returnArray.filter(function(x) {
      return x;
    });
  },
  getNestedObject: async function(table, objectPath) {
    var dataset;
    dataset = (await DB.getTable(table));
    return _.get(dataset[0], objectPath);
  },
  getUniqueArray: function(arr, flatten = false) {
    if (flatten) {
      return _.flattenDeep(_.uniqBy(arr));
    }
    return _.uniqBy(arr);
  },
  mergeMultiple: function(arrayOfArrays) {
    return _.flatten(arrayOfArrays[0].concat(arrayOfArrays[1])).filter(function(x) {
      return x != null;
    });
  },
  getUniqueArrayByProp: function(arr, propOne, propTwo, propThree) {
    var uniqueData;
    uniqueData = _.values(_.keyBy(arr, function(item) {
      return `${item[propOne]}-${item[propTwo]}`;
    }));
    if (propThree) {
      uniqueData = _.values(_.keyBy(arr, function(item) {
        return `${item[propOne]}-${item[propTwo]}-${item[propThree]}`;
      }));
    }
    return uniqueData;
  },
  getUniqueByPropValue: function(arr, propName) {
    var uniqueUsers;
    uniqueUsers = _.uniqBy(arr, propName);
    return uniqueUsers;
  },
  getUniqueArrayFromMultiple: function(arrOne, arrTwo) {
    return _.uniqBy(_.flattenDeep(arrOne, arrTwo));
  },
  sortByProperty: function(arr, prop, direction) {
    //    arr = arr.filter (x) -> x[prop] isnt ""
    if (direction === "asc") {
      return _.sortBy(arr, prop);
    } else {
      return _.sortBy(arr, prop).reverse();
    }
  },
  sortDates: function(arr, direction = "asc") {
    return _.sortBy(arr, function(date) {
      return moment(date).toDate();
    });
  },
  sort: function(arr, direction) {
    if (direction === 'asc') {
      return arr.sort();
    }
    return arr.sort();
  },
  transformArrayProp: function(arr, prop, newType) {
    var i, len, ref, ref1, ref2, val;
    for (i = 0, len = arr.length; i < len; i++) {
      val = arr[i];
      switch (newType) {
        case "js-date":
          if (((ref = val[prop]) != null ? ref.length : void 0) > 0) {
            val[prop] = moment(val[prop]).toDate();
          }
          break;
        case "int":
          if (((ref1 = val[prop]) != null ? ref1.length : void 0) > 0) {
            val[prop] = _.toNumber(val[prop]);
          }
          break;
        case "string":
          if (((ref2 = val[prop]) != null ? ref2.length : void 0) > 0) {
            val[prop] = _.toString(val[prop]);
          }
      }
    }
    return arr;
  }
};

export default DatasetManager;

//# sourceMappingURL=datasetManager.js.map
