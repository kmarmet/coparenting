// Generated by CoffeeScript 2.7.0
var DatasetManager

import _ from "lodash"

import moment from "moment"
import DB from "../database/DB"

import Manager from "./manager"

import ObjectManager from "./objectManager"

DatasetManager = {
      GetDatabaseKeyFromArray: function (arr, getSingleObjectPropName, getSingleObjectProp) {
            var formatted
            if (getSingleObjectProp) {
                  formatted = Object.entries(arr).map(function (x) {
                        return x[1]
                  })
                  console.log(ObjectManager.RecursivelyFindProperty(formatted, getSingleObjectPropName), getSingleObjectProp)
                  return formatted.find(function (x) {
                        return ObjectManager.RecursivelyFindProperty(formatted, getSingleObjectPropName) === getSingleObjectProp
                  })
            } else {
                  return Object.entries(arr).flat()
            }
      },
      CombineArrays: function (arrOne = [], arrTwo = [], isUnique = true, isFlattened = true) {
            var returnArray
            returnArray = []
            arrOne = DatasetManager.GetValidArray(arrOne)
            arrTwo = DatasetManager.GetValidArray(arrTwo)
            if (Manager.IsValid(arrOne)) {
                  returnArray = [...arrOne]
            }
            if (Manager.IsValid(arrTwo)) {
                  returnArray = [...returnArray, ...arrTwo]
            }
            if (isUnique) {
                  returnArray = DatasetManager.getUniqueArray(returnArray)
            }
            if (isFlattened) {
                  returnArray = returnArray.flat()
            }
            return returnArray
      },
      AddToArray: (arr, newItem, removeIfExistsAlready = false) => {
            var returnArray
            returnArray = []
            if (!Manager.IsValid(arr)) {
                  returnArray = [newItem]
            }
            if (Manager.IsValid(arr) && Array.isArray(arr) && arr.length > 0) {
                  returnArray = [...arr, newItem]
            }
            if (Manager.IsValid(arr) && Array.isArray(arr) && arr.length === 0) {
                  returnArray = [newItem]
            }
            if (Manager.IsValid(arr) && !Array.isArray(arr)) {
                  returnArray = [newItem]
            }
            if (removeIfExistsAlready && arr.includes(newItem)) {
                  returnArray = returnArray.filter(function (x) {
                        return x !== newItem
                  })
            }
            if (Manager.IsValid(returnArray)) {
                  returnArray = DatasetManager.GetValidArray(returnArray)
            }
            return returnArray
      },
      ToggleInArray: function (arr, key) {
            if (!Manager.IsValid(arr)) {
                  return [key]
            } else {
                  if (arr.includes(key)) {
                        return arr.filter(function (x) {
                              return x !== key
                        })
                  } else {
                        return [...arr, key]
                  }
            }
      },
      GetValidArray: function (source, isUnique = true, isFlattened = true, getObjectValuesOnly = false) {
            var asArray, returnArray
            returnArray = []
            if (!Manager.IsValid(source)) {
                  return []
            }
            asArray = function (key) {
                  ;({
                        id: key,
                  })
                  return source[key]
            }
            asArray = Object.keys(source).map(asArray)
            returnArray = asArray
            if (!Manager.IsValid(asArray)) {
                  // NOT Array
                  if (!Array.isArray(source)) {
                        source = [source]
                  }
                  // Array
                  if (Array.isArray(source)) {
                        returnArray = returnArray.filter(function (x) {
                              return x
                        })
                  }
            }
            if (isUnique) {
                  returnArray = DatasetManager.getUniqueArray(returnArray, true)
            }
            if (isFlattened) {
                  returnArray = returnArray.flat()
            }
            return returnArray.filter(function (x) {
                  return x
            })
      },
      GetLastItemInArray: function (arr) {
            if (Manager.IsValid(arr)) {
                  return arr[-1]
            }
      },
      getNestedObject: async function (table, objectPath) {
            var dataset
            dataset = await DB.GetTableData(table)
            return _.get(dataset[0], objectPath)
      },
      getUniqueArray: function (arr, flatten = false) {
            if (flatten) {
                  return _.flattenDeep(_.uniqBy(arr))
            }
            return _.uniqBy(arr)
      },
      mergeMultiple: function (arrayOfArrays) {
            return _.flatten(arrayOfArrays[0].concat(arrayOfArrays[1])).filter(function (x) {
                  return x != null
            })
      },
      getUniqueArrayByProp: function (arr, propOne, propTwo, propThree) {
            var uniqueData
            uniqueData = _.values(
                  _.keyBy(arr, function (item) {
                        return `${item[propOne]}-${item[propTwo]}`
                  })
            )
            if (propThree) {
                  uniqueData = _.values(
                        _.keyBy(arr, function (item) {
                              return `${item[propOne]}-${item[propTwo]}-${item[propThree]}`
                        })
                  )
            }
            return uniqueData
      },
      getUniqueByPropValue: function (arr, propName) {
            var uniqueUsers
            uniqueUsers = _.uniqBy(arr, propName)
            return uniqueUsers
      },
      getUniqueArrayFromMultiple: function (arrOne, arrTwo) {
            return _.uniqBy(_.flattenDeep(arrOne, arrTwo))
      },
      sortByProperty: function (arr, prop, direction) {
            //    arr = arr.filter (x) -> x[prop] isnt ""
            if (direction === "asc") {
                  return _.sortBy(arr, prop)
            } else {
                  return _.sortBy(arr, prop).reverse()
            }
      },
      sortDates: function (arr, direction = "asc") {
            return _.sortBy(arr, function (date) {
                  return moment(date).toDate()
            })
      },
      ConvertToObject: function (arr) {
            return Object.assign({}, arr)
      },
      SortByTime: function (arr, direction = "asc") {
            if (direction === "asc") {
                  return arr.sort(function (a, b) {
                        var timeA, timeB
                        timeA = moment(a.startTime, "h:mma")
                        timeB = moment(b.startTime, "h:mma")
                        return timeA - timeB
                  })
            } else {
                  return arr.sort(function (a, b) {
                        var timeA, timeB
                        timeA = moment(a.startTime, "h:mma")
                        timeB = moment(b.startTime, "h:mma")
                        return timeB - timeA
                  })
            }
      },
      SortByDateAndTime: function (arr, direction = "asc") {
            if (direction === "asc") {
                  return arr.sort(function (a, b) {
                        var datetimeA, datetimeB
                        datetimeA = moment(`${a != null ? a.startDate : void 0} ${a != null ? a.startTime : void 0}`, "MM/DD/YYYY h:mma")
                        datetimeB = moment(`${b.startDate} ${b.startTime}`, "MM/DD/YYYY h:mma")
                        return datetimeA - datetimeB
                  })
            } else {
                  return arr.sort(function (a, b) {
                        var datetimeA, datetimeB
                        datetimeA = moment(`${a != null ? a.startDate : void 0} ${a != null ? a.startTime : void 0}`, "MM/DD/YYYY h:mma")
                        datetimeB = moment(`${b.startDate} ${b.startTime}`, "MM/DD/YYYY h:mma")
                        return datetimeB - datetimeA
                  })
            }
      },
      SortByDate: function (arr, direction = "asc", customDateProp = "startDate") {
            if (direction === "asc") {
                  return arr.sort(function (a, b) {
                        return moment(a[customDateProp], "MM/DD/YYYY") - moment(b[customDateProp], "MM/DD/YYYY")
                  })
            } else {
                  return arr.sort(function (a, b) {
                        return moment(b[customDateProp], "MM/DD/YYYY") - moment(a[customDateProp], "MM/DD/YYYY")
                  })
            }
      },
      SortExpenses: function (arr, dataType = "string", direction) {
            if (direction === "asc") {
                  if (dataType === "int") {
                        return arr.sort(function (a, b) {
                              return a.amount - b.amount
                        })
                  } else {
                        return arr.sort(function (a, b) {
                              return a.name.localeCompare(b.name, void 0, {
                                    sensitivity: "base",
                              })
                        })
                  }
            } else if (direction === "desc") {
                  if (dataType === "int") {
                        return arr.sort(function (a, b) {
                              return b.amount - a.amount
                        })
                  } else {
                        return arr.sort(function (a, b) {
                              return b.name.localeCompare(a.name, void 0, {
                                    sensitivity: "base",
                              })
                        })
                  }
            }
      },
      transformArrayProp: function (arr, prop, newType) {
            var i, len, ref, ref1, ref2, val
            for (i = 0, len = arr.length; i < len; i++) {
                  val = arr[i]
                  switch (newType) {
                        case "js-date":
                              if (((ref = val[prop]) != null ? ref.length : void 0) > 0) {
                                    val[prop] = moment(val[prop]).toDate()
                              }
                              break
                        case "int":
                              if (((ref1 = val[prop]) != null ? ref1.length : void 0) > 0) {
                                    val[prop] = _.toNumber(val[prop])
                              }
                              break
                        case "string":
                              if (((ref2 = val[prop]) != null ? ref2.length : void 0) > 0) {
                                    val[prop] = _.toString(val[prop])
                              }
                  }
            }
            return arr
      },
}

export default DatasetManager

//# sourceMappingURL=datasetManager.js.map