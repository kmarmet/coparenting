// Generated by CoffeeScript 2.7.0
var ImageManager;

import SecurityManager from "./securityManager";

import imageCompression from 'browser-image-compression';

import _ from "lodash";

import DB from "database/DB";

import {
  saveAs
} from 'file-saver';

import FirebaseStorage from 'database/firebaseStorage';

import domtoimage from 'dom-to-image';

ImageManager = {
  getStatusCode: function(url) {
    return fetch(url).then(function(response) {
      var statusCode;
      statusCode = response.status;
      return statusCode;
    });
  },
  compressImage: async function(imgFile) {
    var compressedFile, options;
    options = {
      maxSizeMB: 1,
      useWebWorker: true
    };
    compressedFile = (await imageCompression(imgFile, options));
    console.log('compressedFile instanceof Blob', compressedFile instanceof Blob);
    console.log(`compressedFile size ${compressedFile.size / 1024 / 1024} MB`);
    return compressedFile;
  },
  expandImage: function(img, modal) {
    var imageModal, src;
    if (modal == null) {
      modal = document.querySelector('.image-modal');
    }
    src = img.getAttribute('src');
    imageModal = modal;
    imageModal.querySelector('img').setAttribute('src', src);
    return imageModal.classList.add('active');
  },
  formatImageName: function(imageName) {
    return imageName.replace(/\.[^\/.]+$/, '').replaceAll('-', ' ').replaceAll('_', ' ').uppercaseFirstLetterOfAllWords();
  },
  blobToImage: function(blob) {
    return new Promise(function(resolve) {
      var img, url;
      url = URL.createObjectURL(blob);
      img = new Image();
      img.onload = function() {
        URL.revokeObjectURL(url);
        return resolve(img);
      };
      img.src = url;
      return console.log(img);
    });
  },
  navigateToImage: function(direction, imgPaths) {
    var img, imgIndex, src;
    img = document.querySelector('#modal-img');
    src = img.getAttribute('src');
    imgIndex = imgPaths.indexOf(src);
    if (imgIndex > -1 && imgIndex + 1 < imgPaths.length) {
      if (direction === 'forward') {
        return img.src = imgPaths[imgIndex + 1];
      } else {
        if (imgPaths[imgIndex - 1] === void 0) {
          return img.src = imgPaths[imgPaths.length - 1];
        } else {
          return img.src = imgPaths[imgIndex - 1];
        }
      }
    } else {
      return img.src = imgPaths[0];
    }
  },
  getImages: async function(currentUser) {
    var allMemories, memories, returnMemories;
    allMemories = [];
    memories = (await SecurityManager.getMemories(currentUser));
    allMemories = memories;
    await FirebaseStorage.getImages(FirebaseStorage.directories.memories, currentUser.id).then(async function(imgPromises) {
      return (await Promise.all(imgPromises).then(function(images) {
        if (images.length > 0) {
          return allMemories.push(images);
        }
      }));
    });
    returnMemories = allMemories;
    return returnMemories;
  },
  deleteImage: function(currentUser, imgPaths, directory, path) {
    var imageName, memoryImageToDelete, memoryImageToDeleteIndex, newArray, newMemoryObj;
    imageName = FirebaseStorage.getImageNameFromUrl(path);
    memoryImageToDelete = imgPaths.filter(function(x) {
      return x.includes(imageName);
    })[0];
    newArray = imgPaths;
    memoryImageToDeleteIndex = newArray.indexOf(memoryImageToDelete);
    newArray.splice(memoryImageToDeleteIndex, 1);
    newMemoryObj = {
      shareWith: currentUser.memories.shareWith,
      images: newArray
    };
    DB.updateRecord(DB.tables.users, currentUser, 'memories', newMemoryObj);
    return FirebaseStorage.delete(directory, currentUser.id, imageName);
  },
  createImage: function(url) {
    var image;
    image = new Image();
    image.setAttribute('crossOrigin', 'anonymous');
    image.src = url;
    return image;
  },
  getRadianAngle: function(degreeValue) {
    return (degreeValue * Math.PI) / 180;
  },
  saveImageFromUrl: function(imageSelector, url, fileName) {
    return setTimeout(function() {
      var image;
      if (!_.isEmpty(imageSelector)) {
        image = document.querySelector(imageSelector);
        domtoimage.toBlob(image).then(function(blob) {
          return saveAs(blob, fileName);
        });
      }
      if (!_.isEmpty(url)) {
        return saveAs(url, fileName);
      }
    }, 300);
  },
  rotateSize: function(width, height, rotation) {
    var rotRad;
    rotRad = getRadianAngle(rotation);
    return {
      width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),
      height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)
    };
  }
};

export default ImageManager;

//# sourceMappingURL=imageManager.js.map
