// Generated by CoffeeScript 2.7.0
var AppManager;

import Manager from "./manager";

import DB from "../database/DB";

import moment from "moment";

import {
  child,
  getDatabase,
  ref,
  set
} from 'firebase/database';

import DateFormats from "../constants/datetimeFormats";

import DatetimeFormats from "../constants/datetimeFormats";

import DB_UserScoped from "../database/db_userScoped";

import CalendarManager from "./calendarManager";

import FirebaseStorage from "../database/firebaseStorage";

export default AppManager = {
  OperatingSystems: {
    Windows: 'Windows',
    Linux: 'Linux',
    Mac: 'Mac',
    iOS: 'iOS',
    Android: 'Android'
  },
  RefreshIfNecessary: function() {
    var hoursSinceRefresh, lastRefresh, msSinceLastRefresh, ref1;
    // Refresh check
    lastRefresh = localStorage.getItem('lastAutoRefresh');
    // Last refresh exists
    if (Manager.IsValid(lastRefresh)) {
      msSinceLastRefresh = (ref1 = moment(lastRefresh, DatetimeFormats.fullDatetime).diff()) != null ? ref1 : 0;
      hoursSinceRefresh = Math.abs(Math.ceil(msSinceLastRefresh / (1000 * 60 * 60)));
      // If it has been more than 3 hours since the last refresh -> reload the page
      if (hoursSinceRefresh > 3) {
        localStorage.setItem('lastAutoRefresh', moment().format(DatetimeFormats.fullDatetime));
        window.location.reload();
        return false;
      }
    } else {
      // Last refresh does not exist -> set one
      return localStorage.setItem('lastAutoRefresh', moment().format(DatetimeFormats.fullDatetime));
    }
  },
  UpdateOrRefreshIfNecessary: async function(currentUser, currentVersion) {
    var ref1;
    AppManager.RefreshIfNecessary();
    if (Manager.IsValid(currentUser)) {
      if (Manager.IsValid(currentVersion) && currentVersion !== (currentUser != null ? (ref1 = currentUser.app) != null ? ref1.lastVersionSeen : void 0 : void 0)) {
        await DB_UserScoped.updateByPath(`${DB.tables.users}/${currentUser != null ? currentUser.key : void 0}/app/lastVersionSeen`, currentVersion);
        return setTimeout(function() {
          return window.location.reload();
        }, 1000);
      }
    } else {
      return (await DB_UserScoped.updateByPath(`${DB.tables.users}/${currentUser != null ? currentUser.key : void 0}/app/lastVersionSeen`, currentVersion));
    }
  },
  GetOS: function() {
    var iosPlatforms, macosPlatforms, os, platform, userAgent, windowsPlatforms;
    userAgent = window.navigator.userAgent;
    platform = window.navigator.platform;
    macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
    windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
    iosPlatforms = ['iPhone', 'iPad', 'iPod'];
    os = null;
    if (macosPlatforms.indexOf(platform) !== -1) {
      os = AppManager.OperatingSystems.Mac;
    } else if (iosPlatforms.indexOf(platform) !== -1) {
      os = AppManager.OperatingSystems.iOS;
    } else if (windowsPlatforms.indexOf(platform) !== -1) {
      os = AppManager.OperatingSystems.Windows;
    } else if (/Android/.test(userAgent)) {
      os = AppManager.OperatingSystems.Android;
    } else if (!os && /Linux/.test(platform)) {
      os = AppManager.OperatingSystems.Linux;
    }
    return os;
  },
  getIPAddress: async function() {
    var error, ipAddress, myHeaders, requestOptions, response, result;
    ipAddress = '';
    myHeaders = new Headers();
    requestOptions = {
      method: "GET",
      headers: myHeaders,
      redirect: "follow"
    };
    try {
      response = (await fetch("https://api.ipify.org", requestOptions));
      result = (await response.text());
      ipAddress = result;
    } catch (error1) {
      //      console.log result
      error = error1;
      console.error(error);
    }
    return ipAddress;
  },
  getTimezone: async function() {
    var error, ipAddress, myHeaders, ref1, requestOptions, response, result, timezone;
    ipAddress = (await AppManager.getIPAddress());
    timezone = '';
    myHeaders = new Headers();
    myHeaders.append("x-api-key", process.env.REACT_APP_MANY_APIS_API_KEY);
    requestOptions = {
      method: "GET",
      headers: myHeaders,
      redirect: "follow"
    };
    try {
      response = (await fetch(`https://api.manyapis.com/v1-get-ip-detail?ip=${ipAddress}`, requestOptions));
      result = (await response.json());
      timezone = result != null ? (ref1 = result.city) != null ? ref1.timezone : void 0 : void 0;
    } catch (error1) {
      //      console.log result?.city?.timezone
      error = error1;
      console.error(error);
    }
    return timezone;
  },
  getLocationDetails: async function() {
    var error, ipAddress, location, myHeaders, ref1, ref2, ref3, ref4, ref5, requestOptions, response, result;
    ipAddress = (await AppManager.getIPAddress());
    location = {
      city: '',
      timezone: '',
      country: '',
      latitude: '',
      longitude: ''
    };
    myHeaders = new Headers();
    myHeaders.append("x-api-key", process.env.REACT_APP_MANY_APIS_API_KEY);
    requestOptions = {
      method: "GET",
      headers: myHeaders,
      redirect: "follow"
    };
    try {
      response = (await fetch(`https://api.manyapis.com/v1-get-ip-detail?ip=${ipAddress}`, requestOptions));
      result = (await response.json());
      location.ipAddress = ipAddress;
      location.city = result != null ? (ref1 = result.city) != null ? ref1.name : void 0 : void 0;
      location.country = result != null ? (ref2 = result.country) != null ? ref2.name : void 0 : void 0;
      location.latitude = result != null ? (ref3 = result.city) != null ? ref3.latitude : void 0 : void 0;
      location.longitude = result != null ? (ref4 = result.city) != null ? ref4.longitude : void 0 : void 0;
      location.timezone = result != null ? (ref5 = result.city) != null ? ref5.timezone : void 0 : void 0;
    } catch (error1) {
      //      console.log(location)
      //      console.log result
      error = error1;
      console.error(error);
    }
    return location;
  },
  getQueryStringParams: function(queryStringName) {
    var searchParams;
    searchParams = new URLSearchParams(window.location.search);
    if (Manager.IsValid(queryStringName, true)) {
      return searchParams.get(queryStringName);
    }
    return searchParams;
  },
  setAppBadge: (count) => {
    if (window.navigator.setAppBadge) {
      return window.navigator.setAppBadge(count);
    }
  },
  clearAppBadge: () => {
    if (window.navigator.clearAppBadge) {
      return navigator.clearAppBadge();
    }
  },
  isDevMode: () => {
    return location.hostname === 'localhost';
  },
  getAccountType: (currentUser) => {
    if (Manager.IsValid(currentUser)) {
      if (Manager.IsValid(currentUser != null ? currentUser.accountType : void 0)) {
        if ((currentUser != null ? currentUser.accountType : void 0) === 'parent') {
          return 'parent';
        } else {
          return 'child';
        }
      }
      return 'parent';
    }
  },
  deleteExpiredCalendarEvents: async function(currentUser) {
    var daysPassed, event, events, i, len, results;
    events = (await DB.getTable(`${DB.tables.calendarEvents}/${currentUser != null ? currentUser.key : void 0}`));
    if (Manager.IsValid(events)) {
      events = events.filter(function(x) {
        return x != null;
      });
      events = events.flat();
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        daysPassed = moment().diff(event.startDate, 'days');
        if (daysPassed >= 30 || moment(event.startDate).year() !== moment().year()) {
          results.push((await CalendarManager.deleteEvent(currentUser, event.id)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  },
  setUpdateAvailable: async function(updateAvailableValue = null) {
    var dbRef, i, lastUpdateObject, len, timestamp, updateAvailable, updateObject, user, users;
    dbRef = ref(getDatabase());
    users = Manager.convertToArray((await DB.getTable(DB.tables.users)));
// Set updatedAp to false for all users to show update alert
    for (i = 0, len = users.length; i < len; i++) {
      user = users[i];
      await DB_UserScoped.updateUserRecord(user.phone, "updatedApp", false);
    }
    lastUpdateObject = (await DB.getTable("updateAvailable"));
    ({updateAvailable} = lastUpdateObject);
    timestamp = moment().format(DateFormats.fullDatetime);
    updateObject = {
      lastUpdate: timestamp,
      updateAvailable: false
    };
    if (updateAvailableValue !== null && updateAvailableValue !== void 0) {
      updateObject.lastUpdate = timestamp;
      updateAvailable = false;
      set(child(dbRef, "updateAvailable"), updateObject);
      return false;
    }
    if (!Manager.IsValid(updateAvailable) || updateAvailable === false) {
      updateObject.updateAvailable = true;
      return set(child(dbRef, "updateAvailable"), updateObject);
    }
  },
  getLastUpdateObject: async function() {
    var updateObject;
    updateObject = (await DB.getTable("updateAvailable"));
    return updateObject;
  },
  deleteExpiredMemories: async function(currentUser) {
    var daysPassed, i, len, memories, memory, results;
    memories = (await DB.getTable(DB.tables.memories));
    if (Manager.IsValid(memories)) {
      results = [];
      for (i = 0, len = memories.length; i < len; i++) {
        memory = memories[i];
        daysPassed = moment().diff(event.creationDate, 'days');
        if (daysPassed >= 30) {
          await DB.Delete(`${DB.tables.memories}/${currentUser != null ? currentUser.key : void 0}`, memory.id);
          if (Manager.IsValid(memory != null ? memory.memoryName : void 0)) {
            results.push((await FirebaseStorage.delete(FirebaseStorage.directories.memories, currentUser != null ? currentUser.key : void 0, memory != null ? memory.memoryName : void 0)));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  }
};

//# sourceMappingURL=appManager.js.map
