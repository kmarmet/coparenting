// Generated by CoffeeScript 2.7.0
var AppManager

import {child, getDatabase, ref, set} from 'firebase/database'

import moment from 'moment'

import Apis from '../api/apis'

import DateFormats from '../constants/datetimeFormats'
import DatetimeFormats from '../constants/datetimeFormats'

import DB from '../database/DB'

import DB_UserScoped from '../database/db_userScoped'

import Storage from '../database/storage'

import CalendarManager from './calendarManager'
import Manager from './manager'

export default AppManager = {
    OperatingSystems: {
        Windows: 'Windows',
        Linux: 'Linux',
        Mac: 'Mac',
        iOS: 'iOS',
        Android: 'Android',
    },
    RefreshIfNecessary: function () {
        var hoursSinceRefresh, lastRefresh, msSinceLastRefresh, ref1
        // Refresh check
        lastRefresh = localStorage.getItem('lastAutoRefresh')
        // Last refresh exists
        if (Manager.IsValid(lastRefresh)) {
            msSinceLastRefresh = (ref1 = moment(lastRefresh, DatetimeFormats.timestamp).diff()) != null ? ref1 : 0
            hoursSinceRefresh = Math.abs(Math.ceil(msSinceLastRefresh / (1000 * 60 * 60)))
            // If it has been more than 24 hours since the last refresh -> reload the page
            if (hoursSinceRefresh > 24) {
                localStorage.setItem('lastAutoRefresh', moment().format(DatetimeFormats.timestamp))
                window.location.reload()
                return false
            }
        } else {
            // Last refresh does not exist -> set one
            return localStorage.setItem('lastAutoRefresh', moment().format(DatetimeFormats.timestamp))
        }
    },
    GetCurrentAppVersion: async function () {
        var ref1, versions
        versions = await DB.getTable(`${DB.tables.appUpdates}`)
        return (ref1 = versions[(versions != null ? versions.length : void 0) - 1]) != null ? ref1.currentVersion : void 0
    },
    UpdateOrRefreshIfNecessary: async function (currentUser, latestVersion) {
        var ref1, ref2
        AppManager.RefreshIfNecessary()
        if (Manager.IsValid(currentUser)) {
            if (
                !(currentUser != null ? ((ref1 = currentUser.app) != null ? ref1.currentVersion : void 0) : void 0) ||
                (currentUser != null ? ((ref2 = currentUser.app) != null ? ref2.currentVersion : void 0) : void 0) !== latestVersion
            ) {
                await DB_UserScoped.updateByPath(
                    `${DB.tables.users}/${currentUser != null ? currentUser.key : void 0}/app/currentVersion`,
                    latestVersion
                )
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    },
    GetOS: function () {
        var iosPlatforms, macosPlatforms, os, platform, userAgent, windowsPlatforms
        userAgent = window.navigator.userAgent
        platform = window.navigator.platform
        macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K']
        windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE']
        iosPlatforms = ['iPhone', 'iPad', 'iPod']
        os = null
        if (macosPlatforms.indexOf(platform) !== -1) {
            os = AppManager.OperatingSystems.Mac
        } else if (iosPlatforms.indexOf(platform) !== -1) {
            os = AppManager.OperatingSystems.iOS
        } else if (windowsPlatforms.indexOf(platform) !== -1) {
            os = AppManager.OperatingSystems.Windows
        } else if (/Android/.test(userAgent)) {
            os = AppManager.OperatingSystems.Android
        } else if (!os && /Linux/.test(platform)) {
            os = AppManager.OperatingSystems.Linux
        }
        return os
    },
    GetIPAddress: async function () {
        return await Apis.IPify.GetIPAddress()
    },
    GetTimezone: async function () {
        var error, ipAddress, timezone
        ipAddress = await AppManager.GetIPAddress()
        timezone = ''
        try {
            timezone = await Apis.ManyApis.GetTimezone(ipAddress)
        } catch (error1) {
            //      console.log result?.city?.timezone
            error = error1
            console.error(error)
        }
        return timezone
    },
    GetLocationDetails: async function () {
        var error, ipAddress, location, locationDetails, ref1, ref2, ref3, ref4, ref5
        ipAddress = await Apis.IPify.GetIPAddress()
        location = {
            city: '',
            timezone: '',
            country: '',
            latitude: '',
            longitude: '',
        }
        try {
            locationDetails = await Apis.ManyApis.GetLocationDetails(ipAddress)
            location.ipAddress = ipAddress
            location.city = locationDetails != null ? ((ref1 = locationDetails.city) != null ? ref1.name : void 0) : void 0
            location.country = locationDetails != null ? ((ref2 = locationDetails.country) != null ? ref2.name : void 0) : void 0
            location.latitude = locationDetails != null ? ((ref3 = locationDetails.city) != null ? ref3.latitude : void 0) : void 0
            location.longitude = locationDetails != null ? ((ref4 = locationDetails.city) != null ? ref4.longitude : void 0) : void 0
            location.timezone = locationDetails != null ? ((ref5 = locationDetails.city) != null ? ref5.timezone : void 0) : void 0
        } catch (error1) {
            //      console.log(location)
            //      console.log result
            error = error1
            console.error(error)
        }
        return location
    },
    getQueryStringParams: function (queryStringName) {
        var searchParams
        searchParams = new URLSearchParams(window.location.search)
        if (Manager.IsValid(queryStringName, true)) {
            return searchParams.get(queryStringName)
        }
        return searchParams
    },
    SetAppBadge: function (count) {
        if (window.navigator.setAppBadge) {
            return window.navigator.setAppBadge(count)
        }
    },
    clearAppBadge: function () {
        if (window.navigator.clearAppBadge) {
            return navigator.clearAppBadge()
        }
    },
    IsDevMode: function () {
        return window.location.hostname === 'localhost'
    },
    GetAccountType: function (currentUser) {
        if (Manager.IsValid(currentUser)) {
            if (Manager.IsValid(currentUser != null ? currentUser.accountType : void 0)) {
                if ((currentUser != null ? currentUser.accountType : void 0) === 'parent') {
                    return 'parent'
                } else {
                    return 'child'
                }
            }
            return 'parent'
        }
    },
    DeleteExpiredCalendarEvents: async function (currentUser) {
        var daysPassed, event, events, i, len, results
        events = await DB.getTable(`${DB.tables.calendarEvents}/${currentUser != null ? currentUser.key : void 0}`)
        if (Manager.IsValid(events)) {
            events = events.filter(function (x) {
                return x != null
            })
            events = events.flat()
            results = []
            for (i = 0, len = events.length; i < len; i++) {
                event = events[i]
                daysPassed = moment().diff(event.startDate, 'days')
                if (daysPassed >= 30 || moment(event.startDate).year() !== moment().year()) {
                    results.push(await CalendarManager.deleteEvent(currentUser, event.id))
                } else {
                    results.push(void 0)
                }
            }
            return results
        }
    },
    setUpdateAvailable: async function (updateAvailableValue = null) {
        var dbRef, i, lastUpdateObject, len, timestamp, updateAvailable, updateObject, user, users
        dbRef = ref(getDatabase())
        users = Manager.convertToArray(await DB.getTable(DB.tables.users))
        // Set updatedAp to false for all users to show update alert
        for (i = 0, len = users.length; i < len; i++) {
            user = users[i]
            await DB_UserScoped.updateUserRecord(user.phone, 'updatedApp', false)
        }
        lastUpdateObject = await DB.getTable('updateAvailable')
        ;({updateAvailable} = lastUpdateObject)
        timestamp = moment().format(DateFormats.timestamp)
        updateObject = {
            lastUpdate: timestamp,
            updateAvailable: false,
        }
        if (updateAvailableValue !== null && updateAvailableValue !== void 0) {
            updateObject.lastUpdate = timestamp
            updateAvailable = false
            set(child(dbRef, 'updateAvailable'), updateObject)
            return false
        }
        if (!Manager.IsValid(updateAvailable) || updateAvailable === false) {
            updateObject.updateAvailable = true
            return set(child(dbRef, 'updateAvailable'), updateObject)
        }
    },
    getLastUpdateObject: async function () {
        var updateObject
        updateObject = await DB.getTable('updateAvailable')
        return updateObject
    },
    DeleteExpiredMemories: async function (currentUser) {
        var daysPassed, i, len, memories, memory, results
        memories = await DB.getTable(DB.tables.memories)
        if (Manager.IsValid(memories)) {
            results = []
            for (i = 0, len = memories.length; i < len; i++) {
                memory = memories[i]
                daysPassed = moment().diff(event.creationDate, 'days')
                if (daysPassed >= 30) {
                    await DB.Delete(`${DB.tables.memories}/${currentUser != null ? currentUser.key : void 0}`, memory.id)
                    if (Manager.IsValid(memory != null ? memory.memoryName : void 0)) {
                        results.push(
                            await Storage.delete(
                                Storage.directories.memories,
                                currentUser != null ? currentUser.key : void 0,
                                memory != null ? memory.memoryName : void 0
                            )
                        )
                    } else {
                        results.push(void 0)
                    }
                } else {
                    results.push(void 0)
                }
            }
            return results
        }
    },
}

//# sourceMappingURL=appManager.js.map