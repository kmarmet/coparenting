// Generated by CoffeeScript 2.7.0
var ObjectManager;

import ModelNames from "../models/modelNames";

import CalendarEvent from "../models/calendarEvent";

import Expense from "../models/expense";

import Memory from "../models/memory";

import TransferChangeRequest from "../models/transferChangeRequest";

import SwapRequest from "../models/swapRequest";

import User from "../models/user";

import Coparent from "../models/coparent";

import ChatThread from "../models/chat/chatThread";

import ChatMessage from "../models/chat/chatMessage";

import ChildUser from "../models/child/childUser";

import Doc from "../models/doc";

import Child from "../models/child/child";

import _ from "lodash";

import Parent from "../models/parent";

import Manager from "./manager";

import LogManager from "./logManager";

ObjectManager = {
  SetObjectPropertyByPath: function(obj, path, value) {
    obj[path] = value;
    obj = ObjectManager.GetModelValidatedObject(obj, ModelNames.child);
    return obj;
  },
  RemoveUndefinedValues: function(obj) {
    var i, len, prop;
    for (i = 0, len = obj.length; i < len; i++) {
      prop = obj[i];
      if (obj[prop] === void 0) {
        delete obj[prop];
      }
    }
    return obj;
  },
  UpdateObjectByModel: function(obj, updatedPropOrPath, updatedValue, modelObject) {
    var afterUpdate, keys, prop, updated;
    console.log(modelObject);
    for (prop in modelObject) {
      if (modelObject[prop] === void 0) {
        delete modelObject[prop];
      }
      if (modelObject[prop] === null) {
        delete modelObject[prop];
      }
    }
    keys = Object.keys(modelObject);
    updated = _.merge(modelObject, obj);
    afterUpdate = _.set(updated, updatedPropOrPath, updatedValue);
    updated = _.merge(afterUpdate, updated);
    for (prop in updated) {
      if (obj[prop] === void 0) {
        delete obj[prop];
      }
      if (!keys.includes(prop)) {
        delete updated[prop];
      }
    }
    return updated;
  },
  UpdateAndReturnObject: function(obj, path, value) {
    var e, updated;
    try {
      updated = _.set(obj, path, value);
      return ObjectManager.GetValidObject(updated);
    } catch (error) {
      e = error;
      return LogManager.Log(e.message, LogManager.LogTypes.error, e.stack);
    }
  },
  RecursivelyFindProperty: function(obj, key) {
    var prop, result;
    if (Manager.IsValid(obj) && typeof obj === 'object') {
      if (obj.hasOwnProperty(key)) {
        return obj[key];
      }
      for (prop in obj) {
        result = ObjectManager.RecursivelyFindProperty(obj[prop], key);
        if (result !== void 0) {
          return result;
        }
      }
    }
    return void 0;
  },
  GetValidObject: function(obj) {
    return Object.fromEntries(Object.entries(obj).filter(function([_, value]) {
      return Manager.IsValid(value);
    }));
  },
  RemoveUnusedProperties: function(obj, modelKeys) {
    var i, key, len;
    console.log(obj, modelKeys);
    for (i = 0, len = obj.length; i < len; i++) {
      key = obj[i];
      console.log(modelKeys, key);
      if (!modelKeys.includes(key)) {
        delete obj[key];
      }
    }
    return obj;
  },
  GetModelKeys: function(modelName) {
    switch (modelName) {
      case ModelNames.calendarEvent:
        return Object.keys(new CalendarEvent());
      case ModelNames.expense:
        return Object.keys(new Expense());
      case ModelNames.memory:
        return Object.keys(new Memory());
      case ModelNames.transferChangeRequest:
        return Object.keys(new TransferChangeRequest());
      case ModelNames.swapRequest:
        return Object.keys(new SwapRequest());
      case ModelNames.user:
        return Object.keys(new User());
      case ModelNames.coparent:
        return Object.keys(new Coparent());
      case ModelNames.chatThread:
        return Object.keys(new ChatThread());
      case ModelNames.chatMessage:
        return Object.keys(new ChatMessage());
      case ModelNames.childUser:
        return Object.keys(new ChildUser());
      case ModelNames.child:
        return Object.keys(new Child());
      case ModelNames.parent:
        return Object.keys(new Parent());
      case ModelNames.doc:
        return Object.keys(new Doc());
    }
  },
  GetModel: function(modelName) {
    switch (modelName) {
      case ModelNames.calendarEvent:
        return new CalendarEvent();
      case ModelNames.expense:
        return new Expense();
      case ModelNames.memory:
        return new Memory();
      case ModelNames.transferChangeRequest:
        return new TransferChangeRequest();
      case ModelNames.swapRequest:
        return new SwapRequest();
      case ModelNames.inputSuggestion:
        return new InputSuggestion();
      case ModelNames.user:
        return new User();
      case ModelNames.coparent:
        return new Coparent();
      case ModelNames.chatThread:
        return new ChatThread();
      case ModelNames.chatMessage:
        return new ChatMessage();
      case ModelNames.childUser:
        return new ChildUser();
      case ModelNames.child:
        return new Child();
      case ModelNames.parent:
        return new Parent();
      case ModelNames.doc:
        return new Doc();
    }
  },
  GetModelValidatedObject: function(object, modelName) {
    var prop, ref, ref1, returnObject;
    returnObject = (function() {
      switch (modelName) {
        case ModelNames.calendarEvent:
          return new CalendarEvent();
        case ModelNames.expense:
          return new Expense();
        case ModelNames.memory:
          return new Memory();
        case ModelNames.transferChangeRequest:
          return new TransferChangeRequest();
        case ModelNames.swapRequest:
          return new SwapRequest();
        case ModelNames.inputSuggestion:
          return new InputSuggestion();
        case ModelNames.user:
          return new User();
        case ModelNames.coparent:
          return new Coparent();
        case ModelNames.chatThread:
          return new ChatThread();
        case ModelNames.chatMessage:
          return new ChatMessage();
        case ModelNames.childUser:
          return new ChildUser();
        case ModelNames.child:
          return new Child();
        case ModelNames.parent:
          return new Parent();
        case ModelNames.doc:
          return new Doc();
      }
    })();
    for (prop in object) {
      if (Array.isArray(object[prop])) {
        if ((ref = object[prop]) === (void 0) || ref === null) {
          object[prop] = [];
        }
      } else {
        if (((ref1 = object[prop]) === (void 0) || ref1 === null) || object[prop].toString().toLowerCase().includes('invalid')) {
          object[prop] = '';
        }
      }
      returnObject[prop] = object[prop];
    }
    //    returnObject = ObjectManager.GetValidObject(returnObject)
    return returnObject;
  },
  merge: function(objectWithValuesToKeep, objectWithValuesToAdd) {
    return _.assign(objectWithValuesToKeep, objectWithValuesToAdd);
  },
  isEmpty: function(obj) {
    return _.isEmpty(obj);
  }
};

export default ObjectManager;

//# sourceMappingURL=objectManager.js.map
